import numpy as np
from geopy.distance import geodesic
from sklearn.ensemble import RandomForestRegressor
import uuid
#using gps coordinates
# =====================================
# TURN DATABASE
# =====================================

class TurnDatabase:
    def __init__(self):
        # curve_id -> dict with center, radius, avg_speed, std_speed, samples
        self.turns = {}

    def add_new_turn(self, center, radius, avg_speed):
        curve_id = str(uuid.uuid4())[:8]
        self.turns[curve_id] = {
            "center": center,          # (lat, lon)
            "radius": radius,
            "avg_speed": float(avg_speed),
            "std_speed": 0.0,
            "samples": 1
        }
        return curve_id

    def find_closest_turn(self, center, tolerance_m=40):
        """Match current turn to existing turn by geographic proximity."""
        if not self.turns:
            return None

        for curve_id, t in self.turns.items():
            dist = geodesic(center, t["center"]).meters
            if dist < tolerance_m:
                return curve_id

        return None

    def update_turn(self, curve_id, speed_list):
        """Update rolling average + std for a known turn."""
        t = self.turns[curve_id]
        new_avg = float(np.mean(speed_list))
        old_avg = t["avg_speed"]
        n = t["samples"]

        # Rolling average over passes
        t["avg_speed"] = (old_avg * n + new_avg) / (n + 1)
        # Std of the last pass (can be refined later)
        t["std_speed"] = float(np.std(speed_list))
        t["samples"] += 1


# =====================================
# TURN DETECTOR (fixed, robust)
# =====================================

class TurnDetector:
    def __init__(self, turn_threshold_deg=5.0):
        self.prev_bearing = None
        self.prev_point = None
        self.turn_threshold = turn_threshold_deg
        self.current_turn_points = []  # list of (lat, lon, speed)
        self.in_turn = False

    def compute_bearing(self, lat1, lon1, lat2, lon2):
        """Compute bearing between two GPS points in degrees [0, 360)."""
        dLon = np.radians(lon2 - lon1)
        lat1_rad = np.radians(lat1)
        lat2_rad = np.radians(lat2)

        y = np.sin(dLon) * np.cos(lat2_rad)
        x = (np.cos(lat1_rad) * np.sin(lat2_rad) -
             np.sin(lat1_rad) * np.cos(lat2_rad) * np.cos(dLon))
        bearing = np.degrees(np.arctan2(y, x))
        return (bearing + 360.0) % 360.0

    def process_point(self, lat, lon, speed):
        """
        Feed one GPS point.
        Returns: list of turn_points when a turn finishes, else None.
        """
        # First GPS point
        if self.prev_point is None:
            self.prev_point = (lat, lon)
            return None

        # Second GPS point: initialize bearing
        if self.prev_bearing is None:
            self.prev_bearing = self.compute_bearing(
                self.prev_point[0], self.prev_point[1],
                lat, lon
            )
            self.prev_point = (lat, lon)
            return None

        # Normal case
        bearing_now = self.compute_bearing(
            self.prev_point[0], self.prev_point[1],
            lat, lon
        )
        heading_change = abs(bearing_now - self.prev_bearing)

        # We are turning or starting a turn
        if heading_change > self.turn_threshold:
            self.current_turn_points.append((lat, lon, speed))
            self.in_turn = True

        # Heading change small → maybe leaving the turn
        else:
            if self.in_turn and len(self.current_turn_points) >= 3:
                # Turn finished
                turn = self.current_turn_points.copy()
                self.current_turn_points = []
                self.in_turn = False
                self.prev_bearing = bearing_now
                self.prev_point = (lat, lon)
                return turn

        # Update state for next call
        self.prev_bearing = bearing_now
        self.prev_point = (lat, lon)
        return None


# =====================================
# SMART TURN SPEED SYSTEM + AI
# =====================================

class SmartTurnSpeedSystem:
    def __init__(self, min_samples_for_ai=5):
        self.db = TurnDatabase()
        self.detector = TurnDetector()
        self.model = RandomForestRegressor()
        self.training_X = []      # list of feature vectors
        self.training_y = []      # list of safe speeds (avg speeds observed)
        self.trained = False
        self.min_samples_for_ai = min_samples_for_ai

    # ---------- Geometry helpers ----------

    def compute_turn_center(self, turn_points):
        """Approximate center of the turn as centroid of lat/lon."""
        lats = [p[0] for p in turn_points]
        lons = [p[1] for p in turn_points]
        return (float(np.mean(lats)), float(np.mean(lons)))

    def compute_curve_radius(self, turn_points):
        """Approximate radius as average distance of points to centroid."""
        center = self.compute_turn_center(turn_points)
        dists = [geodesic((lat, lon), center).meters for lat, lon, _ in turn_points]
        return float(np.mean(dists))

    def build_turn_features(self, turn_points, radius):
        """
        Build ML features for a turn:
        - radius (m)
        - total bearing change (angle)
        - avg heading change per segment
        - number of points in turn
        """
        if len(turn_points) < 3:
            return [radius, 0.0, 0.0, len(turn_points)]

        # Compute bearings along the turn
        bearings = []
        for i in range(len(turn_points) - 1):
            lat1, lon1, _ = turn_points[i]
            lat2, lon2, _ = turn_points[i+1]
            b = self.detector.compute_bearing(lat1, lon1, lat2, lon2)
            bearings.append(b)

        if not bearings:
            return [radius, 0.0, 0.0, len(turn_points)]

        total_angle = abs(bearings[-1] - bearings[0])

        heading_diffs = []
        for i in range(len(bearings) - 1):
            heading_diffs.append(abs(bearings[i+1] - bearings[i]))

        avg_heading_change = float(np.mean(heading_diffs)) if heading_diffs else 0.0

        return [radius, float(total_angle), avg_heading_change, len(turn_points)]

    # ---------- AI helpers ----------

    def _maybe_train_ai(self):
        if len(self.training_X) >= self.min_samples_for_ai:
            self.model.fit(self.training_X, self.training_y)
            self.trained = True

    def predict_safe_speed(self, features):
        """Predict safe speed using AI (RandomForest)."""
        if not self.trained:
            return None
        features = np.array(features, dtype=float).reshape(1, -1)
        return float(self.model.predict(features)[0])

    # ---------- Main logic ----------

    def process_gps(self, lat, lon, speed):
        """
        Feed one GPS datapoint.
        If a turn ends at this point → returns a dict with info.
        Else → returns None.
        """
        turn_points = self.detector.process_point(lat, lon, speed)
        if turn_points is None:
            return None

        speed_list = [s for _, _, s in turn_points]
        avg_speed = float(np.mean(speed_list))
        center = self.compute_turn_center(turn_points)
        radius = self.compute_curve_radius(turn_points)
        features = self.build_turn_features(turn_points, radius)

        # DB logic
        curve_id = self.db.find_closest_turn(center)
        if curve_id is None:
            curve_id = self.db.add_new_turn(center, radius, avg_speed)
            print(f"[NEW TURN] {curve_id} radius={radius:.1f}m avg_speed={avg_speed:.1f}")
        else:
            self.db.update_turn(curve_id, speed_list)
            print(f"[UPDATE] Turn {curve_id}: avg={self.db.turns[curve_id]['avg_speed']:.1f}, std={self.db.turns[curve_id]['std_speed']:.1f}")

        # AI training sample (features -> avg_speed for this pass)
        self.training_X.append(features)
        self.training_y.append(avg_speed)
        self._maybe_train_ai()

        return {
            "curve_id": curve_id,
            "features": features,
            "avg_speed": avg_speed,
            "radius": radius,
            "turn_points": turn_points
        }

    def check_overspeed(self, curve_id, current_speed, features=None):
        """
        Evaluates overspeed using:
        - rule-based limit (avg + std)
        - AI-predicted safe speed (if trained)
        """
        t = self.db.turns[curve_id]
        safe_rule = t["avg_speed"] + t["std_speed"]
        overs_rule = current_speed > safe_rule

        print(f"[RULE] avg={t['avg_speed']:.1f}, std={t['std_speed']:.1f}, safe≈{safe_rule:.1f}, current={current_speed:.1f}  -> overspeed={overs_rule}")

        overs_ai = None
        safe_ai = None

        if features is not None:
            safe_ai = self.predict_safe_speed(features)
            if safe_ai is not None:
                overs_ai = current_speed > safe_ai
                print(f"[AI]   safe≈{safe_ai:.1f}, current={current_speed:.1f}  -> overspeed={overs_ai}")
            else:
                print("[AI]   Not enough data to train model yet.")

        return {
            "overspeed_rule": overs_rule,
            "safe_rule": safe_rule,
            "overspeed_ai": overs_ai,
            "safe_ai": safe_ai
        }


# =====================================
# SIMPLE TEST
# =====================================

if __name__ == "__main__":
    system = SmartTurnSpeedSystem(min_samples_for_ai=3)

    # One turn shape, repeated with different speeds
    trajectory_turn1_slow = [
        (36.8060, 10.1810, 40),
        (36.8061, 10.1810, 40),
        (36.8062, 10.1810, 40),
        (36.80625, 10.18105, 38),
        (36.80630, 10.18120, 37),
        (36.80633, 10.18140, 36),
        (36.80635, 10.18165, 36),
        (36.80640, 10.18200, 42),
        (36.80645, 10.18200, 45),
    ]

    trajectory_turn1_medium = [
        (36.8060, 10.1810, 55),
        (36.8061, 10.1810, 55),
        (36.8062, 10.1810, 55),
        (36.80625, 10.18105, 50),
        (36.80630, 10.18120, 48),
        (36.80633, 10.18140, 47),
        (36.80635, 10.18165, 47),
        (36.80640, 10.18200, 55),
        (36.80645, 10.18200, 58),
    ]

    trajectory_turn1_fast = [
        (36.8060, 10.1810, 70),
        (36.8061, 10.1810, 70),
        (36.8062, 10.1810, 70),
        (36.80625, 10.18105, 68),
        (36.80630, 10.18120, 67),
        (36.80633, 10.18140, 66),
        (36.80635, 10.18165, 66),
        (36.80640, 10.18200, 75),
        (36.80645, 10.18200, 78),
    ]

    print("=== PASS 1: slow ===")
    for lat, lon, speed in trajectory_turn1_slow:
        res = system.process_gps(lat, lon, speed)
        if res is not None:
            system.check_overspeed(res["curve_id"], speed, res["features"])

    print("\n=== PASS 2: medium ===")
    for lat, lon, speed in trajectory_turn1_medium:
        res = system.process_gps(lat, lon, speed)
        if res is not None:
            system.check_overspeed(res["curve_id"], speed, res["features"])

    print("\n=== PASS 3: fast (should trigger overspeed) ===")
    for lat, lon, speed in trajectory_turn1_fast:
        res = system.process_gps(lat, lon, speed)
        if res is not None:
            system.check_overspeed(res["curve_id"], speed, res["features"])

    print("\n=== STORED TURNS ===")
    print(system.db.turns)

